Here's a **production-grade technical markdown guide** for **Changelog Setup & Contribution Flow** using `git-cliff`, inspired by FAANG-level tooling, best practices, and readability standards.

---

# ğŸ§± GitHub Release + Changelog Setup with `git-cliff`

This guide walks you through a **first-time, end-to-end setup** of semantic versioning, changelog automation, and GitHub release workflows using [`git-cliff`](https://github.com/orhun/git-cliff). Itâ€™s tailored for Python projects following modern engineering practices.

> âœ… Perfect for teams building libraries, ML projects, or API services â€” especially if you care about automation, auditability, and traceability.

---

## âœ… Prerequisites

- Git initialized in your project
- Tags and commit history available
- Homebrew installed (on macOS)
- GitHub repo already created and pushed

---

## âœ… Step 1: Install `git-cliff`

Install via Homebrew (macOS/M1/M2):

```bash
brew install git-cliff
```

> ğŸ§  `git-cliff` is a changelog generator that uses your Git commit messages (e.g., `feat:`, `fix:`, `chore:`) to produce human-readable changelogs. Works great with conventional commits.

---

## âœ… Step 2: Initialize the `git-cliff` Config

From the root of your project:

```bash
git-cliff --init > cliff.toml
```

This creates a default `cliff.toml` config with sensible defaults. You can tune sections, emoji categories, templates, and scopes later.

> ğŸ“„ This file should be committed into source control (`git add cliff.toml`).

---

## âœ… Step 3: Ensure Your Commit is Tagged Correctly

### ğŸ” Check for Tagged Commits

```bash
git log --oneline --decorate
```

Look for a commit like:

```bash
a1b2c3d (tag: v0.1.0) feat: initial scaffolding
```

If your commit doesn't have a `feat:` or other conventional prefix, amend it:

```bash
git commit --amend -m "feat: initial production-ready scaffolding"
```

### ğŸ§¼ Delete an Incorrect Tag (If Needed)

```bash
git tag -d v0.1.0
```

If you're connected to GitHub:

```bash
git push origin :refs/tags/v0.1.0
```

### ğŸ· Create a Clean Tag on HEAD

```bash
git tag -a v0.1.0 -m "feat: Initial production-ready scaffolding"
git push origin v0.1.0
```

---

## âœ… Step 4: Generate the Changelog from the Tag

```bash
git-cliff -o CHANGELOG.md --tag v0.1.0
```

This should produce:

```markdown
# Changelog

## [v0.1.0] - 2025-04-02

### ğŸš€ Features

- Initial production-ready scaffolding

<!-- generated by git-cliff -->
```

> ğŸ’¡ **Why This Matters:** `git-cliff` uses tags to define version boundaries. If thereâ€™s no valid tag or the tag isnâ€™t on a valid conventional commit, it assumes the commit is "unreleased".

---

## âœ… Step 5: Customize `cliff.toml` (Optional but Recommended)

In `cliff.toml`, verify:

```toml
[git]
conventional_commits = true
filter_unconventional = true
tag_pattern = "v[0-9]*"
```

Ensure this changelog body template exists:

```toml
[changelog]
header = "# Changelog\n\nAll notable changes to this project will be documented in this file.\n"
body = """
{% for group, commits in commits | group_by(attribute="group") %}
### {{ group | upper_first }}
{% for commit in commits %}
- {{ commit.message | upper_first }} ([{{ commit.id | truncate(length=7) }}]({{ commit.link }}))
{% endfor %}
{% endfor %}
"""
footer = "<!-- generated by git-cliff -->"
```

---

## âœ… Step 6: Create a GitHub Release

1. Go to your GitHub repo
2. Navigate to: **Releases â†’ Draft a new release**
3. Fill out:
   - **Tag version**: `v0.1.0`
   - **Release title**: `v0.1.0 â€“ Initial Production Setup`
   - **Description**: Paste in the content from `CHANGELOG.md`
4. Click **Publish Release**

---

## âœ… Optional: Automate It with GitHub Actions

Create `.github/workflows/release.yml`:

```yaml
name: ğŸ“¦ Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  release:
    name: Generate Changelog & Create GitHub Release
    runs-on: ubuntu-latest

    steps:
      - name: â¬‡ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ›  Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: ğŸ§± Install git-cliff
        uses: taiki-e/install-action@v2
        with:
          tool: git-cliff

      - name: ğŸ“ Generate changelog
        run: git-cliff -o release-notes.md

      - name: ğŸš€ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: release-notes.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

# ğŸ§‘â€ğŸ’» Contribution Guide (FAANG-Style)

Create a `CONTRIBUTING.md` file with:

```markdown
# ğŸ¤ Contributing to LangChain BookBot

Thanks for your interest in improving this project! Please follow the steps below to contribute like a pro.

## ğŸ§° Prerequisites

- Python 3.10+
- Poetry or `pip install -e ".[dev]"`
- Pre-commit hooks enabled

## âš™ï¸ Set up Dev Environment

```bash
git clone https://github.com/your-org/langchain-bookbot.git
cd langchain-bookbot
python3.10 -m venv .venv
source .venv/bin/activate
pip install -e ".[dev]"
pre-commit install
```

## ğŸ§ª Run Checks

```bash
black .
flake8 .
pytest
```

## ğŸ“ Commit Messages (Conventional Commit Format)

Conventional commits are **structured commit messages** that clearly communicate intent and improve changelog generation. Below are the most common types:

| Type        | Purpose                                                                 |
|-------------|-------------------------------------------------------------------------|
| `feat:`     | New feature or functionality                                            |
| `fix:`      | Bug fix or patch                                                        |
| `chore:`    | Tooling, maintenance, or build-related changes (no user impact)        |
| `docs:`     | Documentation updates (README, docstrings, etc.)                       |
| `refactor:` | Code changes that neither fix a bug nor add a feature                  |
| `style:`    | Code style changes (formatting, linting)                               |
| `test:`     | Adding or refactoring tests                                             |
| `perf:`     | Performance improvements                                                |
| `ci:`       | Changes to CI/CD pipelines                                              |

### ğŸ’¡ Real-World Examples

#### ğŸ“¦ Feature Development
```bash
git commit -m "feat: add collaborative filtering engine for book suggestions"
```

#### ğŸ› Bug Fix
```bash
git commit -m "fix: resolve token mismatch error during OpenAI prompt call"
```

#### ğŸ”§ Tooling / CI
```bash
git commit -m "chore: upgrade pre-commit hooks and enforce Black formatter"
```

#### ğŸ“ Documentation
```bash
git commit -m "docs: add setup instructions and usage to README"
```

#### âš™ï¸ Performance
```bash
git commit -m "perf: cache user query embeddings to reduce latency"
```

#### ğŸ” Refactor
```bash
git commit -m "refactor: modularize recommender pipeline into separate layers"
```

---

## ğŸš€ Release Process

1. Commit changes using conventional commit messages
2. Tag a release:

```bash
git tag -a v1.0.0 -m "feat: added RAG pipeline support"
git push origin v1.0.0
```

3. Let GitHub Actions handle the release ğŸš€

---

```text

# Changelog

## [v0.2.0] - 2025-04-03

### ğŸš€ Features

- Add collaborative filtering engine for book suggestions

### ğŸ› Bug Fixes

- Resolve token mismatch error during OpenAI prompt call

### ğŸ›  Chores

- Upgrade pre-commit hooks and enforce Black formatter

### ğŸ“š Documentation

- Add setup instructions and usage to README

### âš¡ Performance

- Cache user query embeddings to reduce latency

### ğŸ” Refactoring

- Modularize recommender pipeline into separate layers

<!-- generated by git-cliff -->

```