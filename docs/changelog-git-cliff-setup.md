# 🧱 GitHub Release + Changelog Setup with `git-cliff`

This guide walks you through a **first-time, end-to-end setup** of semantic versioning, changelog automation, and GitHub release workflows using [`git-cliff`](https://github.com/orhun/git-cliff). It’s tailored for Python projects following modern engineering practices.

> ✅ Perfect for teams building libraries, ML projects, or API services — especially if you care about automation, auditability, and traceability.

---

## ✅ Prerequisites

- Git initialized in your project
- Tags and commit history available
- Homebrew installed (on macOS)
- GitHub repo already created and pushed

---

## ✅ Step 1: Install `git-cliff`

Install via Homebrew (macOS/M1/M2):

```bash
brew install git-cliff
```

> 🧠 `git-cliff` is a changelog generator that uses your Git commit messages (e.g., `feat:`, `fix:`, `chore:`) to produce human-readable changelogs. Works great with conventional commits.

---

## ✅ Step 2: Initialize the `git-cliff` Config

From the root of your project:

```bash
git-cliff --init > cliff.toml
```

This creates a default `cliff.toml` config with sensible defaults. You can tune sections, emoji categories, templates, and scopes later.

> 📄 This file should be committed into source control (`git add cliff.toml`).

---

## ✅ Step 3: Ensure Your Commit is Tagged Correctly

### 🔍 Check for Tagged Commits

```bash
git log --oneline --decorate
```

Look for a commit like:

```bash
a1b2c3d (tag: v0.1.0) feat: initial scaffolding
```

If your commit doesn't have a `feat:` or other conventional prefix, amend it:

```bash
git commit --amend -m "feat: initial production-ready scaffolding"
```

### 🧼 Delete an Incorrect Tag (If Needed)

```bash
git tag -d v0.1.0
```

If you're connected to GitHub:

```bash
git push origin :refs/tags/v0.1.0
```

### 🏷 Create a Clean Tag on HEAD

```bash
git tag -a v0.1.0 -m "feat: Initial production-ready scaffolding"
git push origin v0.1.0
```

---

## ✅ Step 4: Generate the Changelog from the Tag

```bash
git-cliff -o CHANGELOG.md --tag v0.1.0
```

This should produce:

```markdown
# Changelog

## [v0.1.0] - 2025-04-02

### 🚀 Features

- Initial production-ready scaffolding

<!-- generated by git-cliff -->
```

> 💡 **Why This Matters:** `git-cliff` uses tags to define version boundaries. If there’s no valid tag or the tag isn’t on a valid conventional commit, it assumes the commit is "unreleased".

---

## ✅ Step 5: Customize `cliff.toml` (Optional but Recommended)

In `cliff.toml`, verify:

```toml
[git]
conventional_commits = true
filter_unconventional = true
tag_pattern = "v[0-9]*"
```

Ensure this changelog body template exists:

```toml
[changelog]
header = "# Changelog\n\nAll notable changes to this project will be documented in this file.\n"
body = """
{% for group, commits in commits | group_by(attribute="group") %}
### {{ group | upper_first }}
{% for commit in commits %}
- {{ commit.message | upper_first }} ([{{ commit.id | truncate(length=7) }}]({{ commit.link }}))
{% endfor %}
{% endfor %}
"""
footer = "<!-- generated by git-cliff -->"
```

---

## ✅ Step 6: Create a GitHub Release

1. Go to your GitHub repo
2. Navigate to: **Releases → Draft a new release**
3. Fill out:
   - **Tag version**: `v0.1.0`
   - **Release title**: `v0.1.0 – Initial Production Setup`
   - **Description**: Paste in the content from `CHANGELOG.md`
4. Click **Publish Release**

---

## ✅ Optional: Automate It with GitHub Actions

Create `.github/workflows/release.yml`:

```yaml
name: 📦 Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  release:
    name: Generate Changelog & Create GitHub Release
    runs-on: ubuntu-latest

    steps:
      - name: ⬇ Checkout code
        uses: actions/checkout@v4

      - name: 🛠 Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: 🧱 Install git-cliff
        uses: taiki-e/install-action@v2
        with:
          tool: git-cliff

      - name: 📝 Generate changelog
        run: git-cliff -o release-notes.md

      - name: 🚀 Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: release-notes.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

# 🧑‍💻 Contribution Guide (FAANG-Style)

Create a `CONTRIBUTING.md` file with:

```markdown
# 🤝 Contributing to LangChain BookBot

Thanks for your interest in improving this project! Please follow the steps below to contribute like a pro.

## 🧰 Prerequisites

- Python 3.10+
- Poetry or `pip install -e ".[dev]"`
- Pre-commit hooks enabled

## ⚙️ Set up Dev Environment

```bash
git clone https://github.com/your-org/langchain-bookbot.git
cd langchain-bookbot
python3.10 -m venv .venv
source .venv/bin/activate
pip install -e ".[dev]"
pre-commit install
```

## 🧪 Run Checks

```bash
black .
flake8 .
pytest
```

## 📝 Commit Messages (Conventional Commit Format)

Conventional commits are **structured commit messages** that clearly communicate intent and improve changelog generation. Below are the most common types:

| Type        | Purpose                                                                 |
|-------------|-------------------------------------------------------------------------|
| `feat:`     | New feature or functionality                                            |
| `fix:`      | Bug fix or patch                                                        |
| `chore:`    | Tooling, maintenance, or build-related changes (no user impact)        |
| `docs:`     | Documentation updates (README, docstrings, etc.)                       |
| `refactor:` | Code changes that neither fix a bug nor add a feature                  |
| `style:`    | Code style changes (formatting, linting)                               |
| `test:`     | Adding or refactoring tests                                             |
| `perf:`     | Performance improvements                                                |
| `ci:`       | Changes to CI/CD pipelines                                              |

### 💡 Real-World Examples

#### 📦 Feature Development
```bash
git commit -m "feat: add collaborative filtering engine for book suggestions"
```

#### 🐛 Bug Fix
```bash
git commit -m "fix: resolve token mismatch error during OpenAI prompt call"
```

#### 🔧 Tooling / CI
```bash
git commit -m "chore: upgrade pre-commit hooks and enforce Black formatter"
```

#### 📝 Documentation
```bash
git commit -m "docs: add setup instructions and usage to README"
```

#### ⚙️ Performance
```bash
git commit -m "perf: cache user query embeddings to reduce latency"
```

#### 🔁 Refactor
```bash
git commit -m "refactor: modularize recommender pipeline into separate layers"
```

---

## 🚀 Release Process

1. Commit changes using conventional commit messages
2. Tag a release:

```bash
git tag -a v1.0.0 -m "feat: added RAG pipeline support"
git push origin v1.0.0
```

3. Let GitHub Actions handle the release 🚀

---
## Changelog Example

  ```text

  # Changelog

  ## [v0.2.0] - 2025-04-03

  ### 🚀 Features

  - Add collaborative filtering engine for book suggestions

  ### 🐛 Bug Fixes

  - Resolve token mismatch error during OpenAI prompt call

  ### 🛠 Chores

  - Upgrade pre-commit hooks and enforce Black formatter

  ### 📚 Documentation

  - Add setup instructions and usage to README

  ### ⚡ Performance

  - Cache user query embeddings to reduce latency

  ### 🔁 Refactoring

  - Modularize recommender pipeline into separate layers

  <!-- generated by git-cliff -->

  ```

---

## ✅ When to Run `git-cliff`

There are two major use cases for running `git-cliff`:

### 🧪 1. During Development (local)
To preview or update the changelog as you're working.

✅ Command:

```bash
git-cliff -o CHANGELOG.md
```

This will include all commits since the latest version tag, and group them under:

```markdown
## [Unreleased]
```

🎯 Use this:
- Before a PR to review what changes will be logged
- During sprint planning or testing
- Before tagging a release to confirm scope

### 🚀 2. At Release Time (official)
When you’re publishing a version like `v1.0.0`, `v0.3.0`, etc.

✅ Commands:

```bash
git tag -a v0.1.0 -m "feat: add semantic search pipeline"
git push origin v0.1.0

# Then generate changelog for that version
git-cliff -o CHANGELOG.md --tag v0.1.0
```

This logs all changes up to that version and moves them from “Unreleased” to a real version block.

---

## 📅 Changelog Lifecycle (with Team-Friendly Examples)

| Stage               | Who                     | When          | Action                                                                 | Changelog Entry?           |
|--------------------|--------------------------|---------------|------------------------------------------------------------------------|-----------------------------|
| Feature or fix dev | Developer                | During work   | `git commit -m "feat: add vector similarity matcher"`                 | Appears under Unreleased    |
| Internal doc added | Developer                | During work   | `git commit -m "docs: setup git-cliff guide"`                         | Appears under 📚 Documentation |
| Sprint review or QA| Tech Lead                | Pre-release   | `git-cliff -o CHANGELOG.md`                                           | Reviews Unreleased          |
| Tagging release    | Release Manager / Lead   | At release    | `git tag -a v0.2.0 -m "release: v0.2.0"`
`git-cliff -o CHANGELOG.md --tag v0.2.0` | Entries grouped under version block |
| GitHub Release     | GitHub Actions or manual | Post-release  | Use generated `CHANGELOG.md` as GitHub release body                   | ✅ Finalized                 |

---

## 🔁 Best Practices Summary

- 🔄 Run `git-cliff -o CHANGELOG.md` often during dev to review grouped commits
- 🏁 Run `git-cliff -o CHANGELOG.md --tag vX.Y.Z` every time you cut a release
- 📤 Share the output in GitHub Releases, Slack, or changelog dashboards
- 🛠 Consider automating changelog generation in CI/CD on tag push

### 🔧 Optional: Git Alias for Ease

```bash
git config --global alias.changelog '!git-cliff -o CHANGELOG.md'
```

Now just run:

```bash
git changelog
```

Let me know if you'd like a diagram or markdown cheat sheet for your team. I can drop that into your `docs/` folder.

---

## 🛠️ Troubleshooting Tips

### 🟡 Problem: Duplicate Version Sections in the Changelog

If you see something like:
```markdown
## [0.1.0] - 2025-04-03
### 📚 Documentation
...
## [0.1.0] - 2025-04-03
### 🚀 Features
...
```
This means the **same tag (`v0.1.0`) was applied to multiple commits**.

### ⚠️ Why This Happens
- You’ve manually tagged more than one commit with the same version tag instead of tagging the **latest commit** that includes all previous commits.
- `git-cliff` then treats each tagged commit as a separate version block.

### ✅ Solution: Retag Properly at the Tip of History

```bash
git tag -d v0.1.0
git push origin :refs/tags/v0.1.0  # optional if pushed

# Recreate the tag on the latest commit
git tag -a v0.1.0 -m "release: v0.1.0 – feature + docs"
git push origin v0.1.0

# Regenerate the changelog
git-cliff -o CHANGELOG.md --tag v0.1.0
```

### 🔍 Validate Commit Scope
To confirm what’s in the tag:
```bash
git show v0.1.0
```
You should see all `feat:`, `docs:`, or other relevant commits.

### 🧠 Rule of Thumb:
> Always tag **once** — at the tip of the commit history — when you're ready to cut the release.
> All previous commits will be correctly grouped under that version.

---
### Can You Append Commits to an Existing Tag?
No, Git tags are immutable pointers — once created, they point to a specific commit SHA.

You can move a tag to a new commit, but that’s rewriting history — and if it's already pushed, you’ll need to force push (--force). That’s not recommended in collaborative environments.

#### 🔁 Safer Practice: Tag Only at Release Time
Let your 40+ devs work normally using feat:, fix:, docs:, etc.

Once the sprint ends and the merge train lands into main, the Release Manager tags the latest commit on main.

Run git-cliff only after the tag is created — not continuously during development.
---