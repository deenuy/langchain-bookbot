# ğŸ§± GitHub Release + Changelog Setup with `git-cliff`

This guide walks you through a **first-time, end-to-end setup** of semantic versioning, changelog automation, and GitHub release workflows using [`git-cliff`](https://github.com/orhun/git-cliff). Itâ€™s tailored for Python projects following modern engineering practices.

> âœ… Perfect for teams building libraries, ML projects, or API services â€” especially if you care about automation, auditability, and traceability.

---

## âœ… Prerequisites

- Git initialized in your project
- Tags and commit history available
- Homebrew installed (on macOS)
- GitHub repo already created and pushed

---

## âœ… Step 1: Install `git-cliff`

Install via Homebrew (macOS/M1/M2):

```bash
brew install git-cliff
```

> ğŸ§  `git-cliff` is a changelog generator that uses your Git commit messages (e.g., `feat:`, `fix:`, `chore:`) to produce human-readable changelogs. Works great with conventional commits.

---

## âœ… Step 2: Initialize the `git-cliff` Config

From the root of your project:

```bash
git-cliff --init > cliff.toml
```

This creates a default `cliff.toml` config with sensible defaults. You can tune sections, emoji categories, templates, and scopes later.

> ğŸ“„ This file should be committed into source control (`git add cliff.toml`).

---

## âœ… Step 3: Ensure Your Commit is Tagged Correctly

### ğŸ” Check for Tagged Commits

```bash
git log --oneline --decorate
```

Look for a commit like:

```bash
a1b2c3d (tag: v0.1.0) feat: initial scaffolding
```

If your commit doesn't have a `feat:` or other conventional prefix, amend it:

```bash
git commit --amend -m "feat: initial production-ready scaffolding"
```

### ğŸ§¼ Delete an Incorrect Tag (If Needed)

```bash
git tag -d v0.1.0
```

If you're connected to GitHub:

```bash
git push origin :refs/tags/v0.1.0
```

### ğŸ· Create a Clean Tag on HEAD

```bash
git tag -a v0.1.0 -m "feat: Initial production-ready scaffolding"
git push origin v0.1.0
```

---

## âœ… Step 4: Generate the Changelog from the Tag

```bash
git-cliff -o CHANGELOG.md --tag v0.1.0
```

This should produce:

```markdown
# Changelog

## [v0.1.0] - 2025-04-02

### ğŸš€ Features

- Initial production-ready scaffolding

<!-- generated by git-cliff -->
```

> ğŸ’¡ **Why This Matters:** `git-cliff` uses tags to define version boundaries. If thereâ€™s no valid tag or the tag isnâ€™t on a valid conventional commit, it assumes the commit is "unreleased".

---

## âœ… Step 5: Customize `cliff.toml` (Optional but Recommended)

In `cliff.toml`, verify:

```toml
[git]
conventional_commits = true
filter_unconventional = true
tag_pattern = "v[0-9]*"
```

Ensure this changelog body template exists:

```toml
[changelog]
header = "# Changelog\n\nAll notable changes to this project will be documented in this file.\n"
body = """
{% for group, commits in commits | group_by(attribute="group") %}
### {{ group | upper_first }}
{% for commit in commits %}
- {{ commit.message | upper_first }} ([{{ commit.id | truncate(length=7) }}]({{ commit.link }}))
{% endfor %}
{% endfor %}
"""
footer = "<!-- generated by git-cliff -->"
```

---

## âœ… Step 6: Create a GitHub Release

1. Go to your GitHub repo
2. Navigate to: **Releases â†’ Draft a new release**
3. Fill out:
   - **Tag version**: `v0.1.0`
   - **Release title**: `v0.1.0 â€“ Initial Production Setup`
   - **Description**: Paste in the content from `CHANGELOG.md`
4. Click **Publish Release**

---

## âœ… Optional: Automate It with GitHub Actions

Create `.github/workflows/release.yml`:

```yaml
name: ğŸ“¦ Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  release:
    name: Generate Changelog & Create GitHub Release
    runs-on: ubuntu-latest

    steps:
      - name: â¬‡ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ›  Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: ğŸ§± Install git-cliff
        uses: taiki-e/install-action@v2
        with:
          tool: git-cliff

      - name: ğŸ“ Generate changelog
        run: git-cliff -o release-notes.md

      - name: ğŸš€ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: release-notes.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

# ğŸ§‘â€ğŸ’» Contribution Guide (FAANG-Style)

Create a `CONTRIBUTING.md` file with:

```markdown
# ğŸ¤ Contributing to LangChain BookBot

Thanks for your interest in improving this project! Please follow the steps below to contribute like a pro.

## ğŸ§° Prerequisites

- Python 3.10+
- Poetry or `pip install -e ".[dev]"`
- Pre-commit hooks enabled

## âš™ï¸ Set up Dev Environment

```bash
git clone https://github.com/your-org/langchain-bookbot.git
cd langchain-bookbot
python3.10 -m venv .venv
source .venv/bin/activate
pip install -e ".[dev]"
pre-commit install
```

## ğŸ§ª Run Checks

```bash
black .
flake8 .
pytest
```

## ğŸ“ Commit Messages (Conventional Commit Format)

Conventional commits are **structured commit messages** that clearly communicate intent and improve changelog generation. Below are the most common types:

| Type        | Purpose                                                                 |
|-------------|-------------------------------------------------------------------------|
| `feat:`     | New feature or functionality                                            |
| `fix:`      | Bug fix or patch                                                        |
| `chore:`    | Tooling, maintenance, or build-related changes (no user impact)        |
| `docs:`     | Documentation updates (README, docstrings, etc.)                       |
| `refactor:` | Code changes that neither fix a bug nor add a feature                  |
| `style:`    | Code style changes (formatting, linting)                               |
| `test:`     | Adding or refactoring tests                                             |
| `perf:`     | Performance improvements                                                |
| `ci:`       | Changes to CI/CD pipelines                                              |

### ğŸ’¡ Real-World Examples

#### ğŸ“¦ Feature Development
```bash
git commit -m "feat: add collaborative filtering engine for book suggestions"
```

#### ğŸ› Bug Fix
```bash
git commit -m "fix: resolve token mismatch error during OpenAI prompt call"
```

#### ğŸ”§ Tooling / CI
```bash
git commit -m "chore: upgrade pre-commit hooks and enforce Black formatter"
```

#### ğŸ“ Documentation
```bash
git commit -m "docs: add setup instructions and usage to README"
```

#### âš™ï¸ Performance
```bash
git commit -m "perf: cache user query embeddings to reduce latency"
```

#### ğŸ” Refactor
```bash
git commit -m "refactor: modularize recommender pipeline into separate layers"
```

---

## ğŸš€ Release Process

1. Commit changes using conventional commit messages
2. Tag a release:

```bash
git tag -a v1.0.0 -m "feat: added RAG pipeline support"
git push origin v1.0.0
```

3. Let GitHub Actions handle the release ğŸš€

---
## Changelog Example

  ```text

  # Changelog

  ## [v0.2.0] - 2025-04-03

  ### ğŸš€ Features

  - Add collaborative filtering engine for book suggestions

  ### ğŸ› Bug Fixes

  - Resolve token mismatch error during OpenAI prompt call

  ### ğŸ›  Chores

  - Upgrade pre-commit hooks and enforce Black formatter

  ### ğŸ“š Documentation

  - Add setup instructions and usage to README

  ### âš¡ Performance

  - Cache user query embeddings to reduce latency

  ### ğŸ” Refactoring

  - Modularize recommender pipeline into separate layers

  <!-- generated by git-cliff -->

  ```

---

## âœ… When to Run `git-cliff`

There are two major use cases for running `git-cliff`:

### ğŸ§ª 1. During Development (local)
To preview or update the changelog as you're working.

âœ… Command:

```bash
git-cliff -o CHANGELOG.md
```

This will include all commits since the latest version tag, and group them under:

```markdown
## [Unreleased]
```

ğŸ¯ Use this:
- Before a PR to review what changes will be logged
- During sprint planning or testing
- Before tagging a release to confirm scope

### ğŸš€ 2. At Release Time (official)
When youâ€™re publishing a version like `v1.0.0`, `v0.3.0`, etc.

âœ… Commands:

```bash
git tag -a v0.1.0 -m "feat: add semantic search pipeline"
git push origin v0.1.0

# Then generate changelog for that version
git-cliff -o CHANGELOG.md --tag v0.1.0
```

This logs all changes up to that version and moves them from â€œUnreleasedâ€ to a real version block.

---

## ğŸ“… Changelog Lifecycle (with Team-Friendly Examples)

| Stage               | Who                     | When          | Action                                                                 | Changelog Entry?           |
|--------------------|--------------------------|---------------|------------------------------------------------------------------------|-----------------------------|
| Feature or fix dev | Developer                | During work   | `git commit -m "feat: add vector similarity matcher"`                 | Appears under Unreleased    |
| Internal doc added | Developer                | During work   | `git commit -m "docs: setup git-cliff guide"`                         | Appears under ğŸ“š Documentation |
| Sprint review or QA| Tech Lead                | Pre-release   | `git-cliff -o CHANGELOG.md`                                           | Reviews Unreleased          |
| Tagging release    | Release Manager / Lead   | At release    | `git tag -a v0.2.0 -m "release: v0.2.0"`
`git-cliff -o CHANGELOG.md --tag v0.2.0` | Entries grouped under version block |
| GitHub Release     | GitHub Actions or manual | Post-release  | Use generated `CHANGELOG.md` as GitHub release body                   | âœ… Finalized                 |

---

## ğŸ” Best Practices Summary

- ğŸ”„ Run `git-cliff -o CHANGELOG.md` often during dev to review grouped commits
- ğŸ Run `git-cliff -o CHANGELOG.md --tag vX.Y.Z` every time you cut a release
- ğŸ“¤ Share the output in GitHub Releases, Slack, or changelog dashboards
- ğŸ›  Consider automating changelog generation in CI/CD on tag push

### ğŸ”§ Optional: Git Alias for Ease

```bash
git config --global alias.changelog '!git-cliff -o CHANGELOG.md'
```

Now just run:

```bash
git changelog
```

Let me know if you'd like a diagram or markdown cheat sheet for your team. I can drop that into your `docs/` folder.

---

## ğŸ› ï¸ Troubleshooting Tips

### ğŸŸ¡ Problem: Duplicate Version Sections in the Changelog

If you see something like:
```markdown
## [0.1.0] - 2025-04-03
### ğŸ“š Documentation
...
## [0.1.0] - 2025-04-03
### ğŸš€ Features
...
```
This means the **same tag (`v0.1.0`) was applied to multiple commits**.

### âš ï¸ Why This Happens
- Youâ€™ve manually tagged more than one commit with the same version tag instead of tagging the **latest commit** that includes all previous commits.
- `git-cliff` then treats each tagged commit as a separate version block.

### âœ… Solution: Retag Properly at the Tip of History

```bash
git tag -d v0.1.0
git push origin :refs/tags/v0.1.0  # optional if pushed

# Recreate the tag on the latest commit
git tag -a v0.1.0 -m "release: v0.1.0 â€“ feature + docs"
git push origin v0.1.0

# Regenerate the changelog
git-cliff -o CHANGELOG.md --tag v0.1.0
```

### ğŸ” Validate Commit Scope
To confirm whatâ€™s in the tag:
```bash
git show v0.1.0
```
You should see all `feat:`, `docs:`, or other relevant commits.

### ğŸ§  Rule of Thumb:
> Always tag **once** â€” at the tip of the commit history â€” when you're ready to cut the release.
> All previous commits will be correctly grouped under that version.

---
### Can You Append Commits to an Existing Tag?
No, Git tags are immutable pointers â€” once created, they point to a specific commit SHA.

You can move a tag to a new commit, but thatâ€™s rewriting history â€” and if it's already pushed, youâ€™ll need to force push (--force). Thatâ€™s not recommended in collaborative environments.

#### ğŸ” Safer Practice: Tag Only at Release Time
Let your 40+ devs work normally using feat:, fix:, docs:, etc.

Once the sprint ends and the merge train lands into main, the Release Manager tags the latest commit on main.

Run git-cliff only after the tag is created â€” not continuously during development.
---